import sys
import json
from pathlib import Path
from okta.client import Client as OktaClient
from ._utils import terraform_import_block
from ._users import _get_all_users, _existing_users
from ._groups import _get_all_groups, _existing_groups
from ._applications import _get_all_apps, _existing_apps

class OktaTFImport:
    _instance = None  # Class variable to store the single instance

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            # If no instance exists, create a new one
            cls._instance = super().__new__(cls)
        # Always return the existing instance
        return cls._instance

    def __init__(self, directory: str, config: dict, state_file: str):
        if not hasattr(self, '_initialized'):  # Prevent re-initialization
            self._initialized = True

            self.client = None
            self.state = {}
            self.directory = directory

            # TODO: fix
            self.base_dir = Path(__file__).parent.parent  # repo root
            self.output_dir = self.base_dir / self.directory
            self._setup_client(config)
            self._read_state(state_file)

    def _setup_client(self, config):
        try:
            self.client = OktaClient(config)
        except Exception as e:  # noqa: BLE001
            raise ValueError(f"Error configuring Okta client: {e}")
        
    def _read_state(self, state_file):
        # Read the state file and return the json
        try:
            with open(state_file, 'r') as f:
                self.state = json.load(f)
        except Exception as e:
            print(f"Error reading state file: {e}", file=sys.stderr)
            return {}

    async def _register(self, name, getter_fn, existing_fn):
        written = 0
        skip = []

        try:
            resources = await getter_fn(client=self.client)

            # filter the state for existing resources
            existing_ids = list(filter(existing_fn, self.state.get('values', {}).get('root_module', {}).get('resources', [])))
            skip = [r['values']['id'] for r in existing_ids 
                           if r.get('values').get('id') and len(r['values']) > 0]

            output_file = self.output_dir / f"{name}.import.tf"
            with open(output_file, 'w') as f:
                f.write(f"# Terraform import blocks for Okta {name}\n")
                f.write("# Generated by import.py\n\n")

                for r in resources:
                    if r['id'] in skip:
                        continue

                    f.write(terraform_import_block(r['type'], r['name'], r['id']))
                    written += 1
                
            print(f"Written {written} {name} import blocks to {output_file} (skipped {len(skip)} already in state)")
        except Exception as e:
            print(f"Error processing users: {str(e)}", file=sys.stderr)

    # ---------------- Public API -----------------
    async def close(self):
        if self.client and hasattr(self.client, "close"):
            await self.client.close()
        elif self.client and hasattr(self.client, "_http_client"):
            if hasattr(self.client._http_client, "close"):
                await self.client._http_client.close()
        self.client = None

    async def process_users(self):
        await self._register("users", _get_all_users, _existing_users)
    
    async def process_groups(self):
        await self._register("groups", _get_all_groups, _existing_groups)

    async def process_apps(self):
        await self._register("apps", _get_all_apps, _existing_apps)
