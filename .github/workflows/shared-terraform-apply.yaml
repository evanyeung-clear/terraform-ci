on:
  workflow_call:
    inputs:
      runner:
        description: "Runner to use"
        required: false
        default: ubuntu-latest
        type: string
      directory:
        description: "Directory to run Terraform in"
        required: true
        type: string
      vars_file:
        description: "Optional path to Terraform variables file relative to the directory"
        required: false
        type: string
    secrets:
      sops_age_key:
        description: "Optional if you need to decode the variables file with SOPS"
        required: false
jobs:
  lock:
    runs-on: ${{ inputs.runner }}
    permissions:
      pull-requests: write
      contents: write
      statuses: write

    outputs:
      head_sha: ${{ steps.pr.outputs.head_sha }}
      branch: ${{ steps.pr.outputs.branch }}
      comment_id: ${{ steps.comment.outputs.id }}

    steps:
      - name: comment
        uses: actions/github-script@v7
        id: comment
        with:
          script: |
            const { data: comment } = await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "ðŸš€ Deployment started..."
            })

            core.setOutput("id", comment.id)

      - name: Get PR and commit SHA
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            core.setOutput("head_sha", pr.head.sha);
            core.setOutput("branch", pr.head.ref);
            core.setOutput("mergeable_state", pr.mergeable_state);

      - name: Set commit status to pending
        uses: actions/github-script@v7
        with:
          script: |
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: "${{ steps.pr.outputs.head_sha }}",
              state: "pending",
              target_url: runUrl, 
              context: "terraform-apply",
              description: "Pending - in progress"
            });

      - name: Check if branch is up to date with base branch
        uses: actions/github-script@v7
        with:
          script: |
            // semi-documented enums https://docs.github.com/en/graphql/reference/enums#mergestatestatus
            if ("${{ steps.pr.outputs.mergeable_state }}".toUpperCase() == 'BEHIND') {
              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: ${{ steps.comment.outputs.id }},
                body: "âŒ Branch is not up to date with base branch. Please rebase or merge the latest changes from the base branch."
              });

              // exit early
              core.setFailed('Branch is not up to date with base branch.');
            }

            console.log('Branch is up to date with base branch.');

      - name: Check status checks passed # assume tf plan is a part of the status checks
        uses: actions/github-script@v7
        with:
          script: |
            // Get status API checks
            const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "${{ steps.pr.outputs.head_sha }}"
            });

            // Get Checks API checks (includes GitHub Actions jobs)
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "${{ steps.pr.outputs.head_sha }}"
            });

            console.log('Combined Statuses:', combinedStatus.statuses.map(s => s.context));
            console.log('Checks:', checks.check_runs.map(c => c.name));

            // Filter out ignored status contexts
            const ignored = ['terraform-apply', 'another-check-to-ignore'];
            const requiredStatuses = combinedStatus.statuses.filter(status => !ignored.includes(status.context));
            const failedStatuses = requiredStatuses.filter(status => status.state !== 'success');

            // Filter out ignored check names
            const requiredChecks = checks.check_runs.filter(check => !ignored.includes(check.name));
            const failedChecks = requiredChecks.filter(check => check.conclusion !== 'success' && check.conclusion !== 'neutral' && check.conclusion !== 'skipped');

            if (failedStatuses.length > 0 || failedChecks.length > 0) {
              console.log('Failed statuses:', failedStatuses.map(s => s.context));
              console.log('Failed checks:', failedChecks.map(c => c.name));

              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: ${{ steps.comment.outputs.id }},
                body: "âŒ Status checks have not passed. Please fix the failed checks before proceeding."
              });

              // exit early
              core.setFailed('Status checks have not passed.');
            }

      # ignore for now while testing
      # - name: Check PR is approved
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const { data: reviews } = await github.rest.pulls.listReviews({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         pull_number: context.issue.number
      #       });

      #       const approved = reviews.some(review => review.state.toUpperCase() === 'APPROVED');
      #       if (!approved) {
      #         github.rest.issues.updateComment({
      #           owner: context.repo.owner,
      #           repo: context.repo.repo,
      #           comment_id: ${{ steps.comment.outputs.id }},
      #           body: "âŒ PR is not approved. Please get an approval before proceeding."
      #         });

      #         // exit early
      #         core.setFailed('Terraform apply cannot be run yet, the PR is not approved.');
      #       }

      - name: Check deployment lock
        uses: forevanyeung/lock@e43a0b2920fca2eb45f02bde126d32e09949d419
        id: lock
        with:
          mode: check
          environment: ${{ inputs.directory }}

      - name: Check if lock is for this branch
        if: steps.lock.outputs.locked == 'true'
        uses: actions/github-script@v7
        id: lock-check
        with:
          script: |
            const lockedBranch = `${{ steps.lock.outputs.branch }}`;
            const currentBranch = `${{ steps.pr.outputs.branch }}`;
            console.log(`Locked branch: ${lockedBranch}, Current branch: ${currentBranch}`);

            // Check if the lock is held by this branch
            if (lockedBranch !== currentBranch) {
              console.log(`Lock is held by branch ${lockedBranch}, cannot proceed.`);
              core.setOutput("locked", "true");

              
              // Rewrite the link to use redirect.github.com subdomain
              const originalLink = `${{ steps.lock.outputs.link }}`;
              let redirectLink = originalLink.replace(
                /^https:\/\/github\.com\//,
                'https://redirect.github.com/'
              );

              var body = `
              â›” **Failed to acquire deployment lock** â€” another deployment is currently in progress.

              Only one deployment can run at a time to avoid conflicts. Please wait for the active deployment to complete before trying again.

              ðŸ”— [View the blocking deployment](${redirectLink})              
              `
              
              // comment if unable to obtain lock
              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: ${{ steps.comment.outputs.id }},
                body: body
              });

              // exit early
              core.setFailed('Failed to acquire lock.');
            }

            console.log('Lock is held by this branch, continuing.');
            core.setOutput("locked", "false");

      - name: Get deployment lock
        if: steps.lock.outputs.locked == 'false' || steps.lock-check.outputs.locked == 'false'
        uses: forevanyeung/lock@e43a0b2920fca2eb45f02bde126d32e09949d419
        with:
          mode: lock
          environment: ${{ inputs.directory }}
          link: ${{ github.event.comment.html_url }}
          branch: ${{ steps.pr.outputs.branch }}

  apply:
    runs-on: ${{ inputs.runner }}
    needs: lock
    permissions:
      contents: write
      pull-requests: write
      statuses: write
    defaults:
      run:
        working-directory: ${{ inputs.directory }}

    steps:
      - name: Comment ID
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ needs.lock.outputs.comment_id }},
              body: "âœ… Checks passed, âœ… acquired lock, ðŸš€ starting Terraform apply..."
            });

      - name: Checkout pull request
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/pull/${{ github.event.issue.number }}/head
          # ref: ${{ github.head.ref }}

      - name: Decrypt Terraform variables
        id: decrypt
        uses: ./.github/shared-actions/decrypt-sops
        if: inputs.vars_file != '' && env.SOPS_AGE_KEY != ''
        env:
          SOPS_AGE_KEY: ${{ secrets.sops_age_key }}
        with:
          working_directory: ${{ inputs.directory }}
          input_file: ${{ inputs.vars_file }}
          output_file: terraform.tfvars.json
          sops_age_key: ${{ secrets.sops_age_key }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Bake with Compose
        uses: docker/bake-action@v6
        with:
          source: "{{defaultContext}}:${{ inputs.directory }}"
          set: |
            *.cache-from=type=gha
            *.cache-from=type=inline
            *.cache-to=type=gha,mode=max
            *.output=type=docker

      - name: Freeze speculative Terraform state
        uses: ./.github/shared-actions/copy-tf-state
        with:
          source_workspace: ${{ inputs.directory }}
          destination_workspace: ${{ inputs.directory }}-speculative
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}

      - name: Initialize Terraform
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          docker compose run --rm terraform init -input=false
          docker compose run --rm terraform fmt -check
          docker compose run --rm terraform validate -no-color

      - name: Get Changed Terraform Targets
        id: targets
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          docker compose run --rm terraform plan -refresh=false -lock=false -json | jq -rs '[.[] | .change.resource.addr | select(.!=null) | "-target=\(.)"] | join(" ")' > targets.txt
          echo "targets=\"$(cat targets.txt)\"" >> $GITHUB_OUTPUT

      - name: Run Terraform Apply
        id: apply
        env:
          TF_LOG: DEBUG
          TF_LOG_PATH: terraform-debug.log
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          set +e  # Disable immediate exit on error to handle errors gracefully
          status=0

          # Build terraform apply command based on vars file and SOPS usage
          cmd="terraform apply -no-color -input=false -auto-approve"

          # Only target resources that are modified in code
          targets=${{ steps.targets.outputs.targets }}
          echo "Targets: $targets"
          cmd="$cmd $targets"

          echo "Terraform command: $cmd"

          start=$(date +%s)
          docker compose run --rm $cmd 2>&1 | tee tf.console.txt
          status=${PIPESTATUS[0]}
          end=$(date +%s)

          echo "duration=$((end - start))" >> $GITHUB_OUTPUT
          echo "cmd=$cmd" >> $GITHUB_OUTPUT

          if [ $status -ne 0 ]; then
            echo "Terraform apply failed"
            exit $status
          fi

      - name: Tag commit on successful apply
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          TAG="deploy-${{ inputs.directory }}"
          git tag -f "$TAG"
          git push --force origin "refs/tags/$TAG:refs/tags/$TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Label PR deployment lock
        uses: actions/github-script@v7
        with:
          script: |
            const lockLabel = '${{ inputs.directory }}-lock';
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: [lockLabel]
            });

      - name: Update branch deployment badge
        uses: ./.github/shared-actions/upload-badge
        with:
          label: ${{ inputs.directory }} branch
          message: ${{ needs.lock.outputs.branch }}
          color: ${{ needs.lock.outputs.branch == github.event.repository.default_branch && 'green' || 'red' }}
          style: flat-square
          filename: latest-${{ inputs.directory }}-branch.svg
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Format Terraform Apply Diff
        if: always()
        id: diff
        run: |
          # Strip extra lines from tf.console.txt
          awk '
            BEGIN {skip=0}
            /^Warning:/ {skip=1}
            skip && (/^Note that the -target option/ || /^The -target option/) {skip=2; next} skip==2 && NF==0 {skip=0; next}
            skip {next}
            {print}
          ' tf.console.txt | 
          awk '/^â”€â”€â”€â”€â”€/,EOF {next} {print}' > tf.console.stripped.txt || true

          # Filter lines starting with "  # " and prepend diff-specific symbols based on specific keywords.
          # https://github.com/OP5dev/TF-via-PR
          grep '^  # ' tf.console.txt | sed \
            -e 's/^  # \(.* be created\)/+ \1/' \
            -e 's/^  # \(.* be destroyed\)/- \1/' \
            -e 's/^  # \(.* be updated\|.* be replaced\)/! \1/' \
            -e 's/^  # \(.* be read\)/~ \1/' \
            -e 's/^  # \(.*\)/# \1/' > tf.diff.txt || true

          # Grab the summary lines for the expand text
          awk '/^(Error:|Apply complete!|No changes.|Success)/' tf.console.txt > tf.summary.txt

      - name: Comment Terraform Apply
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            // Helper function to safely read files with a default value
            function safeReadFile(filePath, defaultContent = '') {
              try {
                return fs.readFileSync(filePath, 'utf8');
              } catch (error) {
                console.log(`Warning: Could not read file ${filePath}: ${error.message}`);
                return defaultContent;
              }
            }

            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const diff = safeReadFile('${{ inputs.directory }}/tf.diff.txt', 'No changes detected');
            const summary = safeReadFile('${{ inputs.directory }}/tf.summary.txt', 'View output for details');
            const cleanApply = safeReadFile('${{ inputs.directory }}/tf.console.stripped.txt', 'No apply output available');

            if(${{ job.status == 'failure' }}) {
              var body = `
              **Terraform apply** (Okta ${{ inputs.directory }}) [failed](${runUrl}).
              `
            } else {
              var body = `
              **Terraform apply** (Okta ${{ inputs.directory }}) ran in [${{ steps.apply.outputs.duration }} seconds](${runUrl}).
              \`\`\`
              ${{ steps.apply.outputs.cmd }}
              \`\`\`

              <details>
              <summary>${summary}</summary>

              \`\`\`
              ${cleanApply}
              \`\`\`
              </details>
              `
            }

            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ needs.lock.outputs.comment_id }},
              body: body
            });

      - name: Update check status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const state = (`${{ job.status }}` === 'success') ? 'success' : 'failure';
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const duration = ${{ steps.apply.outputs.duration || 0 }};

            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: "${{ needs.lock.outputs.head_sha }}",
              state: state,
              target_url: runUrl,
              context: "terraform-apply",
              description: state === "success"
                ? `Successful in ${duration}s`
                : `Failed after ${duration}s`
            });

  # TODO: re-apply main if deployment fails
  revert:
    runs-on: ${{ inputs.runner }}
    needs: [lock, apply]
    if: failure() && needs.apply.result == 'failure'
    permissions:
      contents: write
      pull-requests: write
      statuses: write
    defaults:
      run:
        working-directory: ${{ inputs.directory }}

    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4

      - name: Decrypt Terraform variables
        id: decrypt
        uses: ./.github/shared-actions/decrypt-sops
        if: inputs.vars_file != '' && env.SOPS_AGE_KEY != ''
        env:
          SOPS_AGE_KEY: ${{ secrets.sops_age_key }}
        with:
          working_directory: ${{ inputs.directory }}
          input_file: ${{ inputs.vars_file }}
          output_file: terraform.tfvars.json
          sops_age_key: ${{ secrets.sops_age_key }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Bake with Compose
        uses: docker/bake-action@v6
        with:
          source: "{{defaultContext}}:${{ inputs.directory }}"
          set: |
            *.cache-from=type=gha
            *.cache-from=type=inline
            *.cache-to=type=gha,mode=max
            *.output=type=docker

      - name: Initialize Terraform
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          docker compose run --rm terraform init -input=false
          docker compose run --rm terraform fmt -check
          docker compose run --rm terraform validate -no-color

      - name: Run Terraform Apply
        id: apply
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_WORKSPACE: ${{ inputs.directory }}
        run: |
          set +e  # Disable immediate exit on error to handle errors gracefully
          status=0

          # Build terraform apply command based on vars file and SOPS usage
          cmd="terraform apply -no-color -input=false -auto-approve"

          # Add vars file if specified
          if [[ -n "${{ inputs.vars_file }}" ]]; then
            if [[ -n "${{ secrets.sops_age_key }}" && -n "${{ steps.decrypt.outputs.decrypted_file }}" ]]; then
              # Use decrypted file if SOPS was used
              cmd="$cmd -var-file=${{ steps.decrypt.outputs.decrypted_file }}"
              echo "Using SOPS-decrypted vars file: ${{ steps.decrypt.outputs.decrypted_file }}"
            else
              # Use original vars file if no SOPS
              cmd="$cmd -var-file=${{ inputs.vars_file }}"
              echo "Using vars file: ${{ inputs.vars_file }}"
            fi
          fi

          echo "Terraform command: $cmd"

          start=$(date +%s)
          # Run terraform apply and capture output
          docker compose run --rm $cmd 2>&1 | tee tf.console.txt
          status=${PIPESTATUS[0]}
          end=$(date +%s)

          # Always set output variables, even on failure
          echo "duration=$((end - start))" >> $GITHUB_OUTPUT
          echo "cmd=$cmd" >> $GITHUB_OUTPUT

          if [ $status -ne 0 ]; then
            echo "Terraform apply failed with exit code $status"
            exit $status
          fi

      - name: Tag commit on successful apply
        if: always() && steps.apply.outcome == 'success'
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          TAG="deploy-${{ inputs.directory }}"
          git tag -f "$TAG"
          git push --force origin "refs/tags/$TAG:refs/tags/$TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Remove PR deployment lock label
      #   if: always() && steps.apply.outcome == 'success'
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const lockLabel = '${{ inputs.directory }}-lock';
      #       await github.rest.issues.removeLabel({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         issue_number: context.issue.number,
      #         name: lockLabel
      #       });

      - name: Update branch deployment badge
        if: always() && steps.apply.outcome == 'success'
        uses: ./.github/shared-actions/upload-badge
        with:
          label: ${{ inputs.directory }} branch
          message: ${{ github.event.repository.default_branch }}
          color: green
          style: flat-square
          filename: latest-${{ inputs.directory }}-branch.svg
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Release deployment lock
        if: always() && steps.apply.outcome == 'success'
        uses: forevanyeung/lock@e43a0b2920fca2eb45f02bde126d32e09949d419
        with:
          mode: unlock
