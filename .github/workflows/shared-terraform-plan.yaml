name: Terraform Plan

on:
  workflow_call:
    inputs:
      directory:
        description: "Directory to run Terraform in"
        required: true
        type: string
      terraform_version:
        description: "Terraform version to use"
        required: false
        type: string
      vars_file:
        description: "Optional path to Terraform variables file relative to the directory"
        required: false
        type: string
    secrets:
      sops_age_key:
        description: "Optional if you need to decode the variables file with SOPS"
        required: false

jobs:
  plan:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      statuses: write
    defaults:
      run:
        working-directory: ${{ inputs.directory }}

    steps:
      - name: Checkout pull request
        uses: actions/checkout@v4

      - name: Check for .terraform-version file
        id: terraform-version
        run: |
          if [ -n "${{ inputs.terraform_version }}" ]; then
            echo "Using terraform_version input: ${{ inputs.terraform_version }}"
            echo "version=${{ inputs.terraform_version }}" >> $GITHUB_OUTPUT
          elif [ -f ".terraform-version" ]; then
            version=$(cat .terraform-version | tr -d '[:space:]')
            echo "Found .terraform-version file with version: $version"
            echo "version=$version" >> $GITHUB_OUTPUT
          else
            echo "No terraform version specified, using latest"
            echo "version=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ steps.terraform-version.outputs.version || null }}

      - name: Setup SOPS
        if: inputs.vars_file != '' && env.SOPS_AGE_KEY != ''
        env:
          SOPS_AGE_KEY: ${{ secrets.sops_age_key }}
        run: |
          # Download the binary
          curl -Lo sops https://github.com/getsops/sops/releases/download/v3.10.2/sops-v3.10.2.linux.amd64

          # Verify the binary using the checksums file
          echo "79b0f844237bd4b0446e4dc884dbc1765fc7dedc3968f743d5949c6f2e701739  sops" > checksum.txt
          if ! shasum -c checksum.txt; then
            echo "::error title=Checksum failed::The file downloaded does not match the checksum provided."
            exit 1
          fi

          # Add current working directory to PATH
          echo $(pwd) >> "$GITHUB_PATH"

          # Make the binary executable
          chmod +x sops

      - name: Decrypt Terraform variables
        id: decrypt
        if: inputs.vars_file != '' && env.SOPS_AGE_KEY != ''
        env:
          SOPS_AGE_KEY: ${{ secrets.sops_age_key }}
        run: |
          decrypted_variables_file="terraform.tfvars.json"

          sops -d ${{ inputs.vars_file }} > $decrypted_variables_file

          # Set the decrypted file as output
          echo "decrypted_file=$decrypted_variables_file" >> $GITHUB_OUTPUT

          # find enc vars and mask from github output
          echo "Masking decrypted values of variables that were encrypted..."

          # First, identify keys that have ENC[ values in the original encrypted file
          encrypted_keys=$(jq -r 'to_entries[] | select(.value | type == "string" and startswith("ENC[")) | .key' ${{ inputs.vars_file }})

          # Also handle array values that contain ENC[ patterns
          encrypted_array_keys=$(jq -r 'to_entries[] | select(.value | type == "array" and (.[0] | type == "string" and startswith("ENC["))) | .key' ${{ inputs.vars_file }})

          # Combine both sets of keys
          all_encrypted_keys=$(echo -e "$encrypted_keys\n$encrypted_array_keys" | sort -u | grep -v '^$')

          # Now mask the decrypted values of those keys from the decrypted file
          for key in $all_encrypted_keys; do
            # Handle string values
            decrypted_value=$(jq -r --arg key "$key" '.[$key] // empty' $decrypted_variables_file)
            if [[ -n "$decrypted_value" && "$decrypted_value" != "null" ]]; then
              echo "::add-mask::$decrypted_value"
              echo "Masked decrypted value for key: $key"
            fi

            # Handle array values - mask each element
            jq -r --arg key "$key" '.[$key][]? // empty' $decrypted_variables_file 2>/dev/null | while read -r array_value; do
              if [[ -n "$array_value" && "$array_value" != "null" ]]; then
                echo "::add-mask::$array_value"
                echo "Masked decrypted array value for key: $key"
              fi
            done
          done

      - name: Initialize Terraform
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_WORKSPACE: ${{ inputs.directory }}
        run: |
          terraform init -input=false
          terraform fmt -check
          terraform validate -no-color

      - name: Run Terraform Plan
        id: plan
        env:
          TF_TOKEN_APP_TERRAFORM_IO: ${{ secrets.TF_TOKEN_APP_TERRAFORM_IO }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_WORKSPACE: ${{ inputs.directory }}
        run: |
          # Build terraform plan command based on vars file and SOPS usage
          cmd="terraform plan -no-color -input=false"

          # Add vars file if specified
          if [[ -n "${{ inputs.vars_file }}" ]]; then
            if [[ -n "${{ secrets.sops_age_key }}" && -n "${{ steps.decrypt.outputs.decrypted_file }}" ]]; then
              # Use decrypted file if SOPS was used
              cmd="$cmd -var-file=${{ steps.decrypt.outputs.decrypted_file }}"
              echo "Using SOPS-decrypted vars file: ${{ steps.decrypt.outputs.decrypted_file }}"
            else
              # Use original vars file if no SOPS
              cmd="$cmd -var-file=${{ inputs.vars_file }}"
              echo "Using vars file: ${{ inputs.vars_file }}"
            fi
          fi

          echo "Terraform command: $cmd"

          start=$(date +%s)
          $cmd 2> >(tee tf.console.txt) > >(tee tf.console.txt)
          end=$(date +%s)

          echo "duration=$((end - start))" >> $GITHUB_OUTPUT
          echo "cmd=$cmd" >> $GITHUB_OUTPUT

      - name: Format Terraform Plan Diff
        id: diff
        run: |
          # Strip extra lines from tf.console.txt
          awk '
            /Terraform used the selected providers/ { found_start = 1 }
            found_start {
              print
              if (/^(Error:|Plan:|Apply complete!|No changes.|Success)/) { exit }
            }
          ' tf.console.txt > tf.console.stripped.txt || true

          # Filter lines starting with "  # " and prepend diff-specific symbols based on specific keywords.
          # https://github.com/OP5dev/TF-via-PR
          grep '^  # ' tf.console.txt | sed \
            -e 's/^  # \(.* be created\)/+ \1/' \
            -e 's/^  # \(.* be destroyed\)/- \1/' \
            -e 's/^  # \(.* be updated\|.* be replaced\)/! \1/' \
            -e 's/^  # \(.* be read\)/~ \1/' \
            -e 's/^  # \(.*\)/# \1/' > tf.diff.txt || true
          awk '/^(Error:|Plan:|Apply complete!|No changes.|Success)/' tf.console.txt > tf.summary.txt

      - name: Comment Terraform Plan
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            // Helper function to safely read files with a default value
            function safeReadFile(filePath, defaultContent = '') {
              try {
                return fs.readFileSync(filePath, 'utf8');
              } catch (error) {
                console.log(`Warning: Could not read file ${filePath}: ${error.message}`);
                return defaultContent;
              }
            }

            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const diff = safeReadFile('${{ inputs.directory }}/tf.diff.txt', 'No changes detected');
            const summary = safeReadFile('${{ inputs.directory }}/tf.summary.txt', 'View output for details');
            const cleanPlan = safeReadFile('${{ inputs.directory }}/tf.console.stripped.txt', 'No plan output available');

            // Find previous plan comment and mark as out of date
            const planCommentTag = `**Terraform plan** (${{ inputs.directory }})`;
            const outOfDateNotice = 'This plan is out of date. A new plan has been performed.';
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            for (const comment of comments.data) {
              if (comment.body && comment.body.includes(planCommentTag) && !comment.body.includes(outOfDateNotice)) {
                // Prepend '> ' to each line of comment.body for quoting
                const quotedBody = comment.body.split('\n').map(line => '> ' + line).join('\n');
                await github.rest.issues.updateComment({
                  comment_id: comment.id,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '<details><summary>' + outOfDateNotice + '</summary>\n\n' + quotedBody + '\n</details>'
                });
              }
            }

            var body = `
            **Terraform plan** (${{ inputs.directory }}) ran in [${{ steps.plan.outputs.duration }} seconds](${runUrl}).
            \`\`\`
            ${{ steps.plan.outputs.cmd }}
            \`\`\`

            #### Diff of changes
            \`\`\`diff
            ${diff}
            \`\`\`

            <details>
            <summary>${summary}</summary>

            \`\`\`
            ${cleanPlan}
            \`\`\`
            </details>
            `

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })

      - name: Add help to apply commit status
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: "${{ github.event.pull_request.head.sha }}",
              state: "pending",
              context: "terraform-apply",
              description: "Comment \"/terraform apply\" to deploy changes",
            });

  # test:
  #   if: ${{ !always() }}
  #   runs-on: ubuntu-latest
  #   needs: run
  #   steps:
  #     - name: Check Terraform Plan Output
  #       run: |
  #         echo "Checking Terraform Plan Output..."
  #         echo "Terraform plan ran in ${{ needs.run.outputs.terraform_time_elapsed }} seconds."
  #         echo "Terraform command: ${{ needs.run.outputs.terraform_cmd }}"
